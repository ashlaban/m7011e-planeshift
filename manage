#!/usr/bin/env python3
#
#

# TODO list
# 	- Add sane exceptions and error handling
# 	- Add logging with import logger to /var/log/planeshift
#	- Force start, remove the previous lockfile

import signal
import os
import pwd
import sys
import argparse
import logging

import daemon
from setproctitle import setproctitle

class Lockfile(object):
	def __init__(self, branch):
		self.path = '/var/run/planeshift/' + branch + '.lock'

	def read_pid(self):
		with open(self.path, 'r') as pidfile:
			line = pidfile.readline()
			return int(line.strip())
			#raise ValueError('Lockfile does not exist (lockfile={}).'.format(self.path))

	def acquire_lock(self, pid):
		with open(self.path, 'w+') as pidfile:
			pidfile.write(str(pid))
			pidfile.flush()
			os.fsync(pidfile.fileno())
			#raise ValueError('Could not acquire lockfile (lockfile={}).'.format(self.path))

	def release_lock(self, pid):
		if self.read_pid() != pid:
			raise ValueError('Lockfile owned by another process. (lockfile={})'.format(self.path))
		else:
			os.remove(self.path)

	def __enter__(self):
		pid = os.getpid()
		self.acquire_lock(pid)

	# For more info on this signature, see https://docs.python.org/3/library/stdtypes.html#typecontextmanager
	# This is not a complete implementation
	def __exit__(self, exc_type, exc_val, exc_tb):
		pid = os.getpid()
		self.release_lock(pid)

class DaemonManager(object):
		def __init__(self, branch, debug=False):
			self.lockfile = Lockfile(branch)
			self.debug    = debug

		def start(self):
			out = sys.stdout if self.debug else None
			err = sys.stderr if self.debug else None
			
			with daemon.DaemonContext(
				pidfile=self.lockfile,
				stdout=out,
				stderr=err,
				uid=pwd.getpwnam('www').pw_uid,
				gid=pwd.getpwnam('www').pw_gid,
				working_directory='./'
			):
				import run
				run.start()

		def stop(self):
			pid = self.lockfile.read_pid()
			try:
				os.kill(pid, signal.SIGTERM)
			except OSError as exc:
				raise ValueError("Failed to terminate {pid:d}: {exc}".format(pid=pid, exc=exc))

		def restart(self):
			self.stop()
			self.start()

		def status(self):
			try:
				print('Daemon running with pid={pid}.'.format(pid=self.lockfile.read_pid()))
			except FileNotFoundError:
				print('Daemon _not_ running.')

if __name__ == '__main__':
	parser = argparse.ArgumentParser()
	parser.add_argument('branch', default='master', help='')
	parser.add_argument('mode'  , choices=['start', 'stop', 'restart', 'status'], help='')
	parser.add_argument('--debug', action='store_true')
	args = parser.parse_args()

	setproctitle('planeshift-{branch}'.format(branch=args.branch))

	manager = DaemonManager(args.branch, args.debug)

	if args.mode == 'start':
		manager.start()
	elif args.mode == 'stop':
		manager.stop()
	elif args.mode ==  'restart':
		manager.restart()
	elif args.mode ==  'status':
		manager.status()


